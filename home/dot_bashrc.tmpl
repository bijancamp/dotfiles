###########################################
## Early Exit for Non-Interactive Shells ##
###########################################

case $- in
    *i*) ;;
      *) return;;
esac


############
## Prompt ##
############

GRAY="\[\e[0;37m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"
YELLOW="\[\e[1;33m\]"
WHITE="\[\e[1;37m\]"
DEFAULT_COLOR="\[\e[0m\]"

if [[ "$TERM_PROGRAM" == "vscode" ]]; then
  BLUE="\[\e[1;34m\]"
else
  {{ if eq .chezmoi.os "windows" }}
  BLUE="\[\e[0;34m\]"
  {{ else }}
  BLUE="\[\e[1;34m\]"
  {{ end }}
fi

WINDOW_TITLE="Bash"
USER="Bijan"

COMPANY="{{- .company }}"
HOST_PURPOSE="{{- .host.purpose }}"
SUBCONTEXT=""

# Determine context/subcontext based on host type and/or purpose
{{ if eq .host.type "container" }}
CONTEXT="Virtual"
SUBCONTEXT="{{- .host.purpose }}"
{{ else }}
if [[ "${HOST_PURPOSE,,}" == "personal" ]]; then
  CONTEXT="Home"
elif [[ "${HOST_PURPOSE,,}" == "work" ]]; then
  CONTEXT="${COMPANY:-Unknown}"
else
  CONTEXT="Unknown"
fi
{{ end }}

# Lowercase if on non-Windows/macOS
{{ if (not (eq .chezmoi.os "windows" "darwin")) }}
USER="${USER,,}"
CONTEXT="${CONTEXT,,}"
SUBCONTEXT="${SUBCONTEXT,,}"
{{ end }}

# Build context segment of prompt
if [[ -n "${SUBCONTEXT}" ]]; then
  CONTEXT_PROMPT_STRING="${BLUE}${CONTEXT}${WHITE}:${RED}${SUBCONTEXT}"
else
  CONTEXT_PROMPT_STRING="${BLUE}${CONTEXT}"
fi

# Ensure __git_ps1 is loaded for prompt
if ! command -v __git_ps1 &> /dev/null; then
  source ~/.git-prompt.sh
fi

PS1="\[\e]0;${WINDOW_TITLE}\a\]${GREEN}${USER}${WHITE}@${CONTEXT_PROMPT_STRING} ${YELLOW}\w${GRAY}"'`__git_ps1`'"${DEFAULT_COLOR}\n$ "


###########################
## Environment Variables ##
###########################

# Prepends a directory to PATH only if it's not already present
prepend_path() {
  local dir="$1"
  if [[ -z "${dir}" ]]; then
    echo "Usage: prepend_path <directory>" >&2
    return 1
  fi

  case ":${PATH}:" in
    *:"${dir}":*)
      # already in PATH, do nothing
      ;;
    *)
      export PATH="${dir}:${PATH}"
      ;;
  esac
}

prepend_path "$HOME/.local/bin"

# Aspire CLI
[[ -d "$HOME/.aspire/bin" ]] && prepend_path "$HOME/.aspire/bin"

export EDITOR="code --wait"


########################
## Shell Integrations ##
########################

# Enable Kiro shell integration
[[ "$TERM_PROGRAM" == "kiro" ]] && . "$(kiro --locate-shell-integration-path bash)"

# fnm shell setup
if command -v fnm &> /dev/null; then
  eval "$(fnm env --use-on-cd --shell bash)"
fi

# Volta shell setup
if [[ -d "$HOME/.volta" ]]; then
  export VOLTA_HOME="$HOME/.volta"
  export PATH="$VOLTA_HOME/bin:$PATH"
fi


#########################
## Completion Behavior ##
#########################

bind 'TAB':menu-complete
bind '"\e[Z"':menu-complete-backward
bind 'set completion-ignore-case on'
bind 'set show-all-if-ambiguous on'


#############
## Aliases ##
#############

# Enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep="grep --color=auto"
    alias fgrep="fgrep --color=auto"
    alias egrep="egrep --color=auto"
fi

# Git: General
alias g="git"
alias gi="git init"

# Git: Add
alias ga="git add"
alias gaa="git add ."

# Git: Commit
alias gc="git commit"
alias gca="git commit -a"
alias gcm="git commit -m"
alias gcam="git commit -a -m"
alias gcA="git commit --amend"
alias gcAa="git commit --amend -a"
alias gcAm="git commit --amend -m"
alias gcAam="git commit --amend -a -m"

# Git: Status, diffs & logs
alias gs="git status"
alias gd="git diff"
alias gds="git diff --staged"
alias gl="git log"

# Git: Stash
alias gst="git stash"

# Git: Branch/checkout
alias gco="git checkout"
alias gcob="git checkout -b"
alias gbc="git checkout"
alias gbn="git checkout -b"
alias gbR="git branch -m"

# Git: Merge
alias gM="git merge"
alias gMa="git merge --abort"

# Git: Reset
alias gg="git reset"
alias ggh="git reset --hard"
alias ggm="git reset --mixed"
alias ggs="git reset --soft"

# Git: Rebase
alias gR="git rebase"
alias gRa="git rebase --abort"
alias gRc="git rebase --continue"
alias gRi="git rebase -i"

# Git: Cherry-pick
alias gcp="git cherry-pick"
alias gcpa="git cherry-pick --abort"
alias gcpc="git cherry-pick --continue"

# Git: Push, pull, and fetch
alias gP="git push"
alias gPf="git push -f"
alias gp="git pull"
alias gf="git fetch"

# Git: Restore
alias gr="git restore"
alias grs="git restore --staged"

# Prints all Git aliases
git_aliases() {
  local BRIGHT_YELLOW="\033[1;33m"
  local RED="\033[0;31m"
  local BLUE="\033[0;34m"
  local BRIGHT_BLUE="\033[1;34m"
  local RESET="\033[0m"

  local -a names values
  local max=0

  while IFS= read -r line; do
    line="${line#alias }"     # drop leading 'alias '
    local name="${line%%=*}"  # up to '='
    local value="${line#*=}"  # after '='
    value="${value#\'}"       # strip leading quote
    value="${value%\'}"       # strip trailing quote
    names+=("$name")
    values+=("$value")
    (( ${#name} > max )) && max=${#name}
  done < <(alias | grep -E '^alias g[[:alpha:]]*=' | sort)

  local count=${#names[@]}
  local i
  for (( i=0; i<count; i++ )); do
    local name="${names[i]}"
    local value="${values[i]}"
    # Print name with padding so that 'git' starts in same column
    local pad=$(( max - ${#name} + 1 ))

    if [[ "$value" == git ]]; then
      printf "%b:%*s" "${BRIGHT_BLUE}${name}${RESET}" $pad ""
      printf "%b" "${BRIGHT_YELLOW}git${RESET}"
      printf "\n"
    elif [[ "$value" == git* ]]; then
      printf "%b:%*s" "${BRIGHT_BLUE}${name}${RESET}" $pad ""

      local remainder="${value#git }"
      local gitcmd="${remainder%% *}"
      local opts=""

      if [[ "$remainder" != "$gitcmd" ]]; then
        opts="${remainder#"$gitcmd" }"
      fi

      printf "%b %b" "${BRIGHT_YELLOW}git${RESET}" "${RED}${gitcmd}${RESET}"

      if [[ -n "$opts" ]]; then
        # Trim leading whitespace just in case
        opts="${opts#${opts%%[![:space:]]*}}"
        printf " %b" "${BLUE}${opts}${RESET}"
      fi

      printf "\n"
    fi
  done
}

# Git: Alias help
alias g?='git_aliases | less -R'

# chezmoi
alias ch="chezmoi"
alias cha="chezmoi-apply-reload-bash-config --verbose"
alias chcd="chezmoi cd"
alias chd="chezmoi diff"
alias che="chezmoi-edit-reload-bash-config"
alias chi="chezmoi init --verbose"
alias chia="chezmoi-init-apply-reload-bash-config --verbose"
{{ if eq .host.type "container" -}}
alias chiaf="chezmoi-init-for-containers"
{{ else -}}
alias chiaf="chezmoi-init-apply-reload-bash-config --force --verbose"
{{ end -}}
alias chm="chezmoi merge"
alias chma="chezmoi merge-all"
alias chu="chezmoi-update-reload-bash-config --verbose"

# lazygit
alias lg="lazygit"


###############
## Functions ##
###############

chezmoi-run-and-reload-bash-config() {
  chezmoi "$@" && source ~/.bashrc
}

chezmoi-init-apply-reload-bash-config() {
  chezmoi-run-and-reload-bash-config init --apply "$@"
}

{{ if eq .host.type "container" -}}
chezmoi-init-for-containers() {
  chezmoi-init-apply-reload-bash-config --force --verbose "$@"

  # Install Claude MCP servers and agents
  if command -v claude &> /dev/null; then
    claude mcp add playwright npx @playwright/mcp@latest --scope user
    claude mcp add --transport http context7 https://mcp.context7.com/mcp --scope user

    local purpose
    purpose="$(chezmoi data --format json | jq --raw-output '.host.purpose')"

    if [[ "$purpose" == "work" ]]; then
      claude mcp add azure-devops --scope user -- npx -y @azure-devops/mcp "$(cat ~/.secretfiles/work/company-ado-org-name)" -d core work work-items repositories
      claude mcp add angular-cli --scope user -- npx -y @angular/cli mcp

      cp -r ~/.secretfiles/work/claude/agents ~/.claude/agents
      chmod 700 ~/.claude/agents
    fi

    echo "[claude] MCP servers and agents for Claude Code installed successfully."
  fi
}
{{- end }}

chezmoi-apply-reload-bash-config() {
  chezmoi-run-and-reload-bash-config apply "$@"
}

chezmoi-update-reload-bash-config() {
  chezmoi-run-and-reload-bash-config update "$@"
}

chezmoi-edit-reload-bash-config() {
  local target_file="${1:-}"
  chezmoi edit "$@"

  # Only source if editing ~/.bashrc
  if command -v readlink &> /dev/null; then
    local target_abs_path="$(readlink -e "$target_file" 2>/dev/null)"
    local bashrc_abs_path="$(readlink -e ~/.bashrc 2>/dev/null)"

    if [[ -n "$target_abs_path" && -n "$bashrc_abs_path" && "$target_abs_path" == "$bashrc_abs_path" ]]; then
      source ~/.bashrc
    fi
  fi
}

cl() {
  local claude_code_sandbox

  {{ if eq .chezmoi.os "windows" -}}
  claude_code_sandbox="/c/Repos/Local/claude-code-sandbox"
  {{ else if (eq .chezmoi.os "linux" "darwin") -}}
  claude_code_sandbox="$HOME/repos/local/claude-code-sandbox"
  {{ end -}}

  # Check if -p or --print was provided
  for arg in "$@"; do
    if [[ "$arg" == "-p" || "$arg" == "--print" ]]; then
      claude "$@"
      return
    fi
  done

  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    claude "$@"
    return
  fi

  if [[ ! -d "$claude_code_sandbox" ]]; then
    mkdir -p "$claude_code_sandbox" || return
  fi

  cd "$claude_code_sandbox" || return
  claude "$@"
}


{{ if eq .chezmoi.os "windows" }}

##################
## Windows-Only ##
##################

alias cdr="cd /c/Repos"

{{ if eq .host.purpose "personal" }}

source ~/.secretfiles/personal/bash_windows_aliases

{{ else if eq .host.purpose "work" }}

alias build="build_closest -verbosity:minimal -clp:errorsonly"
alias rebuild="build_closest -t:rebuild -verbosity:minimal -clp:errorsonly"

source ~/.secretfiles/work/bash_windows_aliases

build_closest () {
  local repo_root

  repo_root="$(git rev-parse --show-toplevel 2> /dev/null)"

  if [[ $? != 0 ]]; then
    echo "Not in a Git repo!"
    return 1
  fi

  repo_root="$(cygpath "$repo_root")"

  local directory
  directory="$PWD"

  while :; do
    if { directory_buildable "$directory"; }; then
      MSBuild.exe "$directory" "$@"
      break
    fi

    # Reached repo root without finding a buildable directory
    if [[ "$directory" == "$repo_root" ]]; then
      echo "Not within a project or solution!"
      break
    fi

    directory="$(dirname "$directory")"
  done
}

directory_buildable () {
  if ls "$1"/*.csproj &> /dev/null || \
     [[ -f "$directory"/website.publishproj ]] || \
     ls "$1"/*.sln &> /dev/null
  then
    return 0
  fi

  return 1
}

{{ end }}
{{ end }}


{{ if eq .chezmoi.os "linux" }}

##################
## Linux-Only ##
##################

alias cdr="cd ~/repos"

{{ if eq .host.purpose "work" }}
source ~/.secretfiles/work/bash_linux_aliases
{{ end }}

{{ end }}
